# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Blum Blum Shub (B.B.S.) Pseudorandom Number Generator
#'
#' The Blum Blum Shub (B.B.S.) pseudorandom number generator was proposed in 1986 by Lenore Blum, Manuel Blum, and Michael Shub.
#' It is based on the security of the quadratic residuosity problem, making it a cryptographically secure generator.
#' The B.B.S. generator relies on the product of two large prime numbers, \eqn{p} and \eqn{q}, and generates pseudorandom bits by repeatedly squaring a seed value modulo \eqn{n = p \times q}.
#'
#' The generator operates as follows:
#' 1. Select two large prime numbers, \eqn{p} and \eqn{q}, such that both \eqn{p \mod 4 = 3} and \eqn{q \mod 4 = 3}.
#' 2. Set \eqn{n = p \times q}.
#' 3. Choose a seed \eqn{s} such that \eqn{gcd(s, n) = 1}.
#' 4. Generate the sequence using \eqn{x_{i+1} = (x_i)^2 \mod n}, where the initial \eqn{x_0 = s^2 \mod n}.
#' 5. Output the least significant bit (or several bits) of each \eqn{x_i} as the pseudorandom output.
#'
#' @param seed Initial seed for the generator. This should be an integer such that \eqn{gcd(seed, p \times q) = 1}.
#' @param p A large prime number such that \eqn{p \mod 4 = 3}.
#' @param q A large prime number such that \eqn{q \mod 4 = 3}.
#' @param n Number of pseudorandom numbers (or bits) to generate.
#'
#' @return A numeric vector of pseudorandom values generated by the Blum Blum Shub algorithm.
#'
#' @references Lenore Blum, Manuel Blum, and Michael Shub, "A Simple Unpredictable Pseudo-Random Number Generator", SIAM Journal on Computing, 1986.
#'
#'
#' @examples
#'
#' \dontrun{
#' # Example usage of the blumb_blumb_shub function
#' random_numbers <- blumb_blumb_shub(6, 103, 563, 1000)
#' plot(random_numbers)
#' }
#' @export
blumb_blumb_shub <- function(seed, p, q, n) {
    .Call(`_randngen_blumb_blumb_shub`, seed, p, q, n)
}

#' Complementary Multiply with Carry Generator
#'
#'
#' Wikipedia: https://en.wikipedia.org/wiki/Multiply-with-carry_pseudorandom_number_generator#Complementary-multiply-with-carry_generators
cmwc <- function(seed, n, r, bitsize = 32L, a = 7L, c = 4L) {
    .Call(`_randngen_cmwc`, seed, n, r, bitsize, a, c)
}

#' Inversive Congruential Generator
#'
#' Inversive congruential generators are a type of non-linear pseudorandom number generator.They use the modular multiplicative inverse (if it exists) to generate the next number in a sequence. The standard formula for an inversive congruential generator, modulo some prime \eqn{q}, is:
#'  \deqn{
#' x_0 = \text{seed}, \quad x_{i+1} = \left\{
#' \begin{array}{ll}
#' (a x_i^{-1} + c) \mod q & \text{if } x_i \neq 0, \\
#' c & \text{if } x_i = 0.
#' \end{array} \right.
#' } where \eqn{x_i^{-1}} represents the modular inverse of \eqn{x_i} modulo \eqn{q}, and \eqn{a} and \eqn{c} are constants.
#'
#' For more information, please see the \href{https://en.wikipedia.org/wiki/Inversive_congruential_generator}{Wikipedia Page}.
#'
#' @param q The modulus (q > 1). This determines the range of possible values in the generated sequence. The output values will be in the range [0, q-1]. A common choice is a large prime number.
#' @param a The multiplier used in the modular inverse step. It must be an integer and should be chosen such that `a` and `q` are coprime (i.e., gcd(a, q) = 1) for the ICG to work correctly.
#' @param c The constant added at each step of the sequence. It is used to ensure the sequence remains pseudo-random. A common choice is to set `c` to 0, but non-zero values of `c` can also be used to shift the sequence.
#' @param seed The initial starting value for the sequence. It must be a non-negative integer and serves as the first value from which the sequence is generated.
#' @param n The number of random numbers to generate in the sequence.
#' @examples
#' # Based off of Wikipedia's example
#' random_numbers <- icg(5,2,3,1,10)
#' # Plot numbers to see that they are random
#' plot(random_numbers)
#' @export
icg <- function(q, a, c, seed, n) {
    .Call(`_randngen_icg`, q, a, c, seed, n)
}

#' Linear Congruential Generator
#'
#'A linear congruential generator (LCG) is an algorithm that yields a sequence of pseudo-randomized numbers calculated with a discontinuous piecewise linear equation. The method represents one of the oldest and best-known pseudorandom number generator algorithms. The theory behind them is relatively easy to understand, and they are easily implemented and fast, especially on computer hardware which can provide modular arithmetic by storage-bit truncation.
#'
#'
#' The generator is defined by the recurrence relation:
#' \deqn{X_{n+1} = (aX + c) \text{ mod } m}
#' Where \eqn{X} is the sequence of pseudo-random values and
#'
#' - \eqn{m, 0 < m} - the "modulus"
#'
#' - \eqn{a, 0 < a < m} - the "multiplier"
#'
#' - \eqn{c, 0 \le c < m} - the "increment"
#'
#' - \eqn{X_0, 0 \le X_0 < m} - the "seed" or "start value"
#'
#' For more information see the \href{https://en.wikipedia.org/wiki/Linear_congruential_generator}{Wikipedia page}.
#'
#' @param seed initial starting value
#' @param n the number of random numbers you want to create.
#' @param m modulus argument. By default, \eqn{m = 2^16  + 1} (follows ZX81 configuration)
#' @param a multiplier argument. By default, \eqn{a = 75} (follows ZX81 configuration)
#' @param c increment argument By default, \eqn{c = 74} (follows ZX81 configuration)
#' @examples
#' random_numbers <- lcg(1234, 1000)
#' # Plot numbers to see that they are random
#' plot(random_numbers)
#' @export
lcg <- function(seed, n, m = 65537L, a = 75L, c = 74L) {
    .Call(`_randngen_lcg`, seed, n, m, a, c)
}

lcg_internal <- function(seed, n) {
    .Call(`_randngen_lcg_internal`, seed, n)
}

#' Park Miller Generator
#'
#' The Lehmer random number generator[1] (named after D. H. Lehmer), sometimes also referred to as the Parkâ€“Miller random number generator (after Stephen K. Park and Keith W. Miller), is a type of linear congruential generator (LCG) that operates in multiplicative group of integers modulo n. The general formula is:\cr\cr
#' \eqn{\displaystyle X_{k+1}=a\cdot X_{k}{\text{ mod } {m}},}\cr\cr
#'where the modulus m is a prime number or a power of a prime number, the multiplier a is an element of high multiplicative order modulo m (e.g., a primitive root modulo n), and the seed \eqn{X_0} is coprime to \eqn{m}.
#'
#' Other names are multiplicative linear congruential generator (MLCG)[2] and multiplicative congruential generator (MCG).
#'
#' For more information see the \href{https://en.wikipedia.org/wiki/Lehmer_random_number_generator}{Wikipedia page}.
#'
#' @param seed initial starting value
#' @param n the number of random numbers you want to create.
#' @examples
#' random_numbers <- lcg_parkmiller(1234, 1000)
#' # Plot numbers to see that they are random
#' plot(random_numbers)
#' @export
lcg_parkmiller <- function(seed, n) {
    .Call(`_randngen_lcg_parkmiller`, seed, n)
}

#' Lagged Fibonacci Generator (LFG)
#'
#' A Lagged Fibbonacci Generator (LFG or sometimes LFib) is an example of a pseudorandom number generator. This class of pseudorandom number generator is aimed at being an improvment of the 'standard' linear congruential generator.  These are based on the generalization of the Fibbonacci sequence.\cr\cr
#' The Fibonacci sequence may be described by the recurrence relation:\cr\cr
#' \eqn{S_n = S_{n-1}+S_{n-2}}\cr\cr
#' Hence, the new term is the sum of the last two terms in the sequence This can be generalized by the sequence:\cr\cr
#' \eqn{S_n \eqiv S_{n-j} \star S_{n-k} \space (\text{mod }m), 0 < j <k}\cr\cr
#' In which case, the new term is some combination of any two previous terms. m is usually a power of 2 (m = 2M), often 232 or 264. The  \star operator denotes a general binary operation. This may be either addition, subtraction, multiplication, or the bitwise exclusive-or operator (XOR). In this package, the \star operator denotes addition.The theory of this type of generator is rather complex, and it may not be sufficient simply to choose random values for j and k. These generators also tend to be very sensitive to initialisation.
#'
#' For more information, see the \href{https://en.wikipedia.org/wiki/Lagged_Fibonacci_generator}{Wikipedia page}.
#'
#' @param int n number of random numbers to generate.
#' @param j \eqn{j} value specified. Note \eqn{0 < j <k}.
#' @param k  \eqn{k} value specified. Note \eqn{0 < j <k}.
#' @param bitsize maximum number of bits got \eqn{m}
#' @examples
#' random_numbers <- lfg(10000)
#' # Plot numbers to see that they are random
#' plot(random_numbers)
#' @export
lfg <- function(n, j = 65L, k = 71L, bitsize = 32L) {
    .Call(`_randngen_lfg`, n, j, k, bitsize)
}

#' Fibonacci Linear Feedback Shift Register (LFSR)
#'
#' This function generates a sequence of numbers using a Fibonacci Linear Feedback Shift Register (LFSR).
#' LFSR is a shift register that produces a pseudo-random sequence of binary numbers based on the initial seed value and the feedback configuration.
#'
#' @param seed A large integer (64-bit) representing the initial value of the LFSR.
#' @param n Integer specifying the number of numbers to generate.
#' @param bitsize Integer specifying the number of bits in the LFSR. This determines the register's length.
#' @param taps A numeric vector specifying the tap positions used to calculate the feedback bit. The values should correspond to bit positions (1-based indexing).
#'
#' @return A numeric vector containing the sequence of generated numbers from the LFSR.
#'
#' @details
#' The function implements a Fibonacci LFSR, where the feedback bit is computed by XOR-ing selected bits (as determined by the tap positions). The register is then shifted, and the feedback bit is inserted into the most significant position.
#'
#' @examples
#' lfsr_fib(seed = 12345, n = 1000, bitsize = 16, taps =c(1, 3,4,6))|>
#'  plot()
#'
#' @seealso \href{https://en.wikipedia.org/wiki/Linear-feedback_shift_register}{Linear Feedback Shift Register on Wikipedia}
#'
#' @export
lfsr_fib <- function(seed, n, bitsize, taps) {
    .Call(`_randngen_lfsr_fib`, seed, n, bitsize, taps)
}

#' Galois Linear Feedback Shift Register
#'
#' Named after the French mathematician Ã‰variste Galois, an LFSR in Galois configuration, which is also known as modular, internal XORs, or one-to-many LFSR, is an alternate structure that can generate the same output stream as a conventional LFSR (but offset in time).[5] In the Galois configuration, when the system is clocked, bits that are not taps are shifted one position to the right unchanged. The taps, on the other hand, are XORed with the output bit before they are stored in the next position. The new output bit is the next input bit. The effect of this is that when the output bit is zero, all the bits in the register shift to the right unchanged, and the input bit becomes zero. When the output bit is one, the bits in the tap positions all flip (if they are 0, they become 1, and if they are 1, they become 0), and then the entire register is shifted to the right and the input bit becomes 1.
#'
#' @param seed Initial seed for the LFSR. This will be the starting state of the LFSR.
#' @param n Number of random numbers to generate.
#' @param bitsize The size of the LFSR in bits (e.g., 16-bit, 32-bit).
#' @param taps A vector of tap positions to apply feedback (XOR). Tap positions should be 1-based.
#'
#' @return A numeric vector of pseudorandom values generated by the LFSR.
#'
#' @examples
#' # Example usage of the LFSR function
#' random_numbers <- lfsr_galois(seed = 12345, n = 1000, bitsize = 16, taps =c(1, 3,4,6))
#' plot(random_numbers)
#'
#' @seealso \href{https://en.wikipedia.org/wiki/Linear-feedback_shift_register}{Linear Feedback Shift Register on Wikipedia}
#' @export
lfsr_galois <- function(seed, n, bitsize, taps) {
    .Call(`_randngen_lfsr_galois`, seed, n, bitsize, taps)
}

#' Xorshift Linear Feedback Shift Register
#'
#' For more information, check out the \href{https://en.wikipedia.org/wiki/Linear-feedback_shift_register}{Wikipedia Page}.
lfsr_xorshift <- function(seed, n, bitsize, taps) {
    .Call(`_randngen_lfsr_xorshift`, seed, n, bitsize, taps)
}

#' Middles-Square Method
#'
#' The middle-square method is a method for generating pseudorandom numbers. In practice it is highly flawed for many practical purposes. Its period is usually very short and it possesses some severe weaknesses. Repeated enough times, the middle-square method will either begin repeatedly generating the same number or cycle to the previous number in a sequence and loop indefinitely.
#'
#' Despite its weaknesses, the middle-square method is a good introductory example for how pseudorandom number generators work. This C++ code is based on the python code shared on Wikipedia (\href{https://en.wikipedia.org/wiki/Middle-square_method#Example_implementation}{link}). For more information check out the \href{https://en.wikipedia.org/wiki/Middle-square_method}{Wikipedia}
#'
#'
#' @param seed initial starting value
#' @param n number of random numbers desired
#' @examples
#' random_numbers <- middlesquare(1234, 1000)
#' # Plot numbers to see that they are random
#' plot(random_numbers)
#' @export
middlesquare <- function(seed, n) {
    .Call(`_randngen_middlesquare`, seed, n)
}

#' Multiply With Carry (MWC)
#'
#' The multiply-with-carry (MWC) method is a method invented by \href{https://en.wikipedia.org/wiki/George_Marsaglia}{George Marsaglia} for generating sequences of random integers based on an initial set of from two to many thousands of randomly chosen seed values. The main advantages of the MWC method are that it invokes simple computer integer arithmetic and leads to very fast generation of sequences of random numbers with immense periods, ranging from around \eqn{2^{60}} to \eqn{2^{20000000}}.
#'
#' A MWC generator is a special form of a Lehmer Random Number Generator (see \code{\link{lcg_parkmiller}}) \eqn{x_n=bx_{n-1} \mod p} which allows efficient implementation of a prime modulus \eqn{p} much larger than the machine word size.
#'
#' Normal Lehmer generator implementations choose a modulsus close to the machine word size. A MWC generator instead maintains its state it base \eqn{b}, so multiplying by \eqn{b} is done implicitly by shifting one word. The base \eqn{b} is typically chosen to equal the computer's word size, as this makes the arithmetic modulo \eqn{b} trivial. This may vary from \eqn{b=2^8} for a microcontroller to \eqn{b=2^{64}}.
#'
#'The initial seed values are arbitrary,except that they must not all e zero, nor at the maximum permitted values (\eqn{x_0 =b-1 \text{ and } c_0 = a-1}).
#'
#' The \code{mwc()} function implements creates a lag-1 MWC with the seed values. That is:
#'
#' \eqn{x_n = (ax_{n-1} + c_{n-1}) \mod b, c = \lfloor{\frac{ax_{n-1}+c_{n-1}}{b}} \rfloor}
#'
#' For more information, see the \href{https://en.wikipedia.org/wiki/Multiply-with-carry_pseudorandom_number_generator}{Wikipedia page}.
#'
#' @param seed initial starting value
#' @param n number of random numbers desired to be generated
#' @param b by default set to \eqn{2^{32} = 4294967296}
#' @param a by default set to 7
#' @param c by default set to 4
#' @export
#' @examples
#' random_numbers <- mwc(6793,1000)
#' # Plot numbers to see that they are random
#' plot(random_numbers)
#' @export
mwc <- function(seed, n, b = 4294967296L, a = 7L, c = 4L) {
    .Call(`_randngen_mwc`, seed, n, b, a, c)
}

#' Winchman-Hill
#'
#' The Wichmann-Hill random number generator indeed produces pseudorandom numbers that are typically in the range \eqn{\left[0, 1\right)}. It generates floating-point numbers rather than discrete integers.
#'
#' For more information see the \href{https://en.wikipedia.org/wiki/Wichmannâ€“Hill}{Wikipedia Page}
#'
#' @param seed1 Initial seed value.
#' @param seed2 Initial seed value.
#' @param seed3 Initial seed value.
#' @param n Number of random numbers to generate.
#' @examples
#' random_numbers <- winchmann_hill(1234, 4321,5678,1000)
#' # Plot numbers to see that they are random
#' plot(random_numbers)
#' @export
winchmann_hill <- function(seed1, seed2, seed3, n) {
    .Call(`_randngen_winchmann_hill`, seed1, seed2, seed3, n)
}

