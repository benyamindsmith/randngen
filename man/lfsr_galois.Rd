% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/RcppExports.R
\name{lfsr_galois}
\alias{lfsr_galois}
\title{Galois Linear Feedback Shift Register}
\usage{
lfsr_galois(seed, n, bitsize, taps)
}
\arguments{
\item{seed}{Initial seed for the LFSR. This will be the starting state of the LFSR.}

\item{n}{Number of random numbers to generate.}

\item{bitsize}{The size of the LFSR in bits (e.g., 16-bit, 32-bit).}

\item{taps}{A vector of tap positions to apply feedback (XOR). Tap positions should be 1-based.}
}
\value{
A numeric vector of pseudorandom values generated by the LFSR.
}
\description{
Named after the French mathematician Ã‰variste Galois, an LFSR in Galois configuration, which is also known as modular, internal XORs, or one-to-many LFSR, is an alternate structure that can generate the same output stream as a conventional LFSR (but offset in time).[5] In the Galois configuration, when the system is clocked, bits that are not taps are shifted one position to the right unchanged. The taps, on the other hand, are XORed with the output bit before they are stored in the next position. The new output bit is the next input bit. The effect of this is that when the output bit is zero, all the bits in the register shift to the right unchanged, and the input bit becomes zero. When the output bit is one, the bits in the tap positions all flip (if they are 0, they become 1, and if they are 1, they become 0), and then the entire register is shifted to the right and the input bit becomes 1.
}
\examples{
# Example usage of the LFSR function
random_numbers <- lfsr_galois(seed = 12345, n = 1000, bitsize = 16, taps =c(1, 3,4,6))
plot(random_numbers)

}
\seealso{
\href{https://en.wikipedia.org/wiki/Linear-feedback_shift_register}{Linear Feedback Shift Register on Wikipedia}
}
