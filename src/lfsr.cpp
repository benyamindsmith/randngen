#include <Rcpp.h>
#include <math.h>
using namespace Rcpp;

//' Fibonacci Linear Feedback Shift Register (LFSR)
//'
//' This function generates a sequence of numbers using a Fibonacci Linear Feedback Shift Register (LFSR).
//' LFSR is a shift register that produces a pseudo-random sequence of binary numbers based on the initial seed value and the feedback configuration.
//'
//' @param seed A large integer (64-bit) representing the initial value of the LFSR.
//' @param n Integer specifying the number of numbers to generate.
//' @param bitsize Integer specifying the number of bits in the LFSR. This determines the register's length.
//' @param taps A numeric vector specifying the tap positions used to calculate the feedback bit. The values should correspond to bit positions (1-based indexing).
//'
//' @return A numeric vector containing the sequence of generated numbers from the LFSR.
//'
//' @details
//' The function implements a Fibonacci LFSR, where the feedback bit is computed by XOR-ing selected bits (as determined by the tap positions). The register is then shifted, and the feedback bit is inserted into the most significant position.
//'
//' @examples
//' lfsr_fib(seed = 12345, n = 1000, bitsize = 16, taps =c(1, 3,4,6))|>
//'  plot()
//'
//' @seealso \href{https://en.wikipedia.org/wiki/Linear-feedback_shift_register}{Linear Feedback Shift Register on Wikipedia}
//'
//' @export
// [[Rcpp::export]]

 NumericVector lfsr_fib(long long seed, int n, int bitsize, NumericVector taps) {
   NumericVector generated_numbers;
   long long lfsr = seed;
   long long bit;

   for(int i = 0; i < n; i++) {
     // Compute the feedback bit using XOR over the tap positions
     bit = 0;  // Reset bit to 0
     for(int j = 0; j < taps.size(); j++) {
       bit ^= (lfsr >> (static_cast<int>(taps[j]) - 1)) & 1;  // Cast tap to int and use for XOR
     }

     // Shift the LFSR and insert the new bit at the most significant position
     lfsr = (lfsr >> 1) | (bit << (bitsize - 1));

     // Store the current LFSR value in the generated numbers
     generated_numbers.push_back(lfsr);
   }

   return generated_numbers;
 }



//' Galois Linear Feedback Shift Register (LFSR)
//'
//' Named after the French mathematician Ã‰variste Galois, an LFSR in Galois configuration, which is also known as modular, internal XORs, or one-to-many LFSR, is an alternate structure that can generate the same output stream as a conventional LFSR (but offset in time).[5] In the Galois configuration, when the system is clocked, bits that are not taps are shifted one position to the right unchanged. The taps, on the other hand, are XORed with the output bit before they are stored in the next position. The new output bit is the next input bit. The effect of this is that when the output bit is zero, all the bits in the register shift to the right unchanged, and the input bit becomes zero. When the output bit is one, the bits in the tap positions all flip (if they are 0, they become 1, and if they are 1, they become 0), and then the entire register is shifted to the right and the input bit becomes 1.
//'
//' @param seed Initial seed for the LFSR. This will be the starting state of the LFSR.
//' @param n Number of random numbers to generate.
//' @param bitsize The size of the LFSR in bits (e.g., 16-bit, 32-bit).
//' @param taps A vector of tap positions to apply feedback (XOR). Tap positions should be 1-based.
//'
//' @return A numeric vector of pseudorandom values generated by the LFSR.
//'
//' @examples
//' # Example usage of the LFSR function
//' random_numbers <- lfsr_galois(seed = 12345, n = 1000, bitsize = 16, taps =c(1, 3,4,6))
//' plot(random_numbers)
//'
//' @seealso \href{https://en.wikipedia.org/wiki/Linear-feedback_shift_register}{Linear Feedback Shift Register on Wikipedia}
//' @export
// [[Rcpp::export]]

 NumericVector lfsr_galois(long long seed, int n, int bitsize, NumericVector taps) {
   // Vector to store the generated random numbers
   NumericVector generated_numbers;

   // Start with the seed as the initial state
   long long lfsr = seed;

   // Variable to store the bit feedback result
   long long bit;

   // Generate `n` random numbers
   for (int i = 0; i < n; ++i) {
     // Get the LSB (least significant bit) of the current state (Galois LFSR works from LSB)
     bit = lfsr & 1;

     // Shift the LFSR to the right
     lfsr >>= 1;

     // XOR feedback only if the output bit is 1 (Galois LFSR rule)
     if (bit) {
       // Apply the feedback taps by XORing the LFSR with the tap mask
       for (int j = 0; j < taps.size(); ++j) {
         lfsr ^= (1LL << (bitsize - static_cast<int>(taps[j]))); // Convert taps[j] to integer before shifting
       }
     }

     // Store the generated number
     generated_numbers.push_back(lfsr);
   }

   return generated_numbers;
 }



// Testing
/*** R
lfsr_galois(seed = 51966, n = 1000, bitsize = 32, taps =c(16, 14,13,11))|>
plot(main = "Galois LFSR")

lfsr_fib(seed = 51966, n = 1000, bitsize = 32, taps =c(16, 14,13, 11))|>
  plot(main = "Fibbonacci LFSR")
*/
